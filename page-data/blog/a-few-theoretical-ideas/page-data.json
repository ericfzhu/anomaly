{
    "componentChunkName": "component---src-pages-blog-contentful-blog-post-title-js",
    "path": "/blog/a-few-theoretical-ideas/",
    "result": {"data":{"contentfulBlogPost":{"title":"A Few Theoretical Ideas","text":{"childMarkdownRemark":{"html":"<p>Our methods build on a special data structure called the matrix profile which computes the pairwise distances between subsequences of a given window length and records a list of ‘nearest neighbour indices’ (subsequences that match each other the closest in the time series); these indices play an important role in <em>semantic segmentation</em>. Each nearest neighbour index defines an ‘arc’ (like an arrow) from one data point to another, and for each data point, we can count the number of times an arc crosses above the point. When the statistical properties of the generating random process changes significantly over a period of time, the number of arcs crossing over points in and around the transition decreases significantly, since it is unlikely a subsequence of the first regime is a nearest neighbour for a subsequence of the second regime! After dividing by a correction factor (We need to account for the fact that in the baseline random-neighbours scenario, we naturally expect more crossovers\nfor data points in the center than data points on the extremities.), we obtain the <em>Corrected Arc Curve</em> (CAC), which ‘reacts’ numerically to perceived regime changes (insert image of CAC). Even better, the matrix profile gives interpretable meaning to the anomalous transitions it detects. Contrast this with the difficult-to-interpret black-box methods popularised by neural learning, which is particularly inapplicable to high-risk operations (such as the building data set we consider in this blog post) where understanding how a model categorises failure/anomalies is almost as important\nas the categorisation itself. We refer to <a href=\"https://stumpy.readthedocs.io/en/latest/\">https://stumpy.readthedocs.io/en/latest/</a>, in particular Tutorials/Semantic Segmentation, for more details on the theoretical foundations of the matrix profile.</p>\n<p>Given a single time-series signal, we can apply the matrix profile, obtain the CAC and figure out where the transition occurs from this single source of information. However, information from a single CAC is often noisy by itself - see, for example, 3, where we can just about see three main ‘peaks’, but with a high degree of uncertainty. We have an array of 24 sensors in our data - how can we use this extra data to ensemble together predictions and increase stability?\n<img src=\"//images.ctfassets.net/j1i7j7n6v3mr/3M0XlhUJC3hhxAjahNa6FC/d227783e4dbd8c8d0d5519c4794db492/noisy_cac_single.jpg\" alt=\"noisy cac single\"></p>\n<p>Figure 3: CAC from a single signal. We can just about see three peaks in with large magnitudes (and a false positive on the left), but these features are not distinct at all. The next piece in the puzzle is the Wasserstein barycenter, a method from the theory of optimal transport used for combining information from multiple probability distributions while retaining the\nmost important features from each distribution. The Wasserstein barycenter <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ν</mi></mrow><annotation encoding=\"application/x-tex\">ν</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.06366em;\">ν</span></span></span></span></span> of a set of distributions <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>μ</mi><mi>i</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{μi\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">}</span></span></span></span></span> is the minimising distribution of the squared sum of Wasserstein distances,</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>ν</mi><mo>:</mo><mo>=</mo><munder><mrow><mi mathvariant=\"normal\">arg min</mi><mo>⁡</mo></mrow><mi>ν</mi></munder><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><msup><mrow><mo fence=\"true\">[</mo><mi mathvariant=\"script\">W</mi><mo stretchy=\"false\">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>ν</mi><mo stretchy=\"false\">)</mo><mo fence=\"true\">]</mo></mrow><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\nu := \\argmin_{\\nu} \\sum_{i=1}^n \\lambda_i \\left[\\mathcal{W}(\\mu_i, \\nu)\\right]^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.06366em;\">ν</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.9291em;vertical-align:-1.2777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6679em;\"><span style=\"top:-2.2056em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.06366em;\">ν</span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">arg</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">min</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">W</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.06366em;\">ν</span><span class=\"mclose\">)</span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>where each <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">W</mi><mo stretchy=\"false\">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>ν</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{W}(\\mu_i, \\nu)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">W</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.06366em;\">ν</span><span class=\"mclose\">)</span></span></span></span></span>measures how much `energy' it takes to move the distribution <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mu_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> to the distribution <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ν</mi></mrow><annotation encoding=\"application/x-tex\">\\nu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.06366em;\">ν</span></span></span></span></span>, and the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\lambda_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> are adjustable \"cost metrics\". A nice image that emphasises the importance of methods extending beyond naive Euclidean averaging for anomalous is Figure 4. Despite each distribution having the same anomalous spike feature, each data set being off-set in time from each other creates destructive interference after averaging. Comparing Figure 3 and Figure 5, the essential peaks become more pronounced and smoothed out after performing the barycenter.\n<img src=\"//images.ctfassets.net/j1i7j7n6v3mr/2Qg4VAfQgl5VCuwiVL9wan/ba57404553f541322c09094ecdc33988/mean_bad.PNG\" alt=\"mean bad\">\nFigure 4: Naive Euclidean averaging destroys the main features from the anomalous spike from each distribution. Effectively working with sensor array data means being able to combine the information from each sensor while retaining the most important features - this is where the Wasserstein barycenter comes in! Image Credit: <a href=\"https://github.com/fpetitjean/DBA\">https://github.com/fpetitjean/DBA</a>\n<img src=\"//images.ctfassets.net/j1i7j7n6v3mr/DqrbtcSnAuuBg9FndOtK0/5054d33580955043568a2734cd3f5208/bary_combined_CAC_24.jpg\" alt=\"bary combined CAC 24\">\nFigure 5: The same CAC as in the previous figure, but barycentered over all 24 sensors. Notice the much clearer and smoother peaks. We can now confidently note the locations of possible regime changes.</p>\n<p>For a (more formal) introduction to the matrix profile, see the STUMPY documentation <a href=\"https://stumpy.readthedocs.io/en/latest/Tutorial_The_Matrix_Profile.html\">https://stumpy.readthedocs.io/en/latest/Tutorial_The_Matrix_Profile.html</a>. STUMPY is a code package implementing the matrix profile with efficient algorithms, and has been invaluable in the results of this project. For the Wasserstein barycenter, the library Python Optimal Transport (see\n<a href=\"https://pythonot.github.io/\">https://pythonot.github.io/</a>) was likewise essential to our work and provides an introduction to the use of optimal transport in data mining contexts.</p>\n<h2>Algorithm Description</h2>\n<p>Let's put all of these ingredients together into a coherent data pipeline. For each input signal, compute their VMD with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> modes (so each input returns <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> output time series for each mode). Apply the Welch transform to each mode (we are now in the frequency domain), take the log and re-scale (this is just for smoothing purposes). Concatenate the transformed data belonging to the same sensor and same VMD together into one long time series. We now compute the matrix profiles and CACs of each concatenated sequence. Each of these CACs will <code>respond' in some way to a perceived anomalous transition (see image of CAC dip), and we wish to combine these responses together. This is where the Wasserstein barycenter comes in! We barycenter the VMDs together (so 5 VMDs become a single time series) and finally compute the barycenter of the data over the sensors (so 24 sensors worth of data becomes a single time series). Peaks of this final CAC corresponds to segments of high </code>disruption', in the sense that subsequences to the left of the peak tend to be related to other subsequences on the left, and subsequences to the right tend to be related to other subsequences on the right. Hence, it makes sense to postulate that an anomalous transition has taken place in-between.</p>\n<p>See Figure 6 for a flowchart of the proposed (offline) methodology that summarises our explanations above. It works `offline' since we assume all of the data has completely arrived before we process it and figure out where the anomalous transitions take place (if there are any!).\n<img src=\"//images.ctfassets.net/j1i7j7n6v3mr/5gFPpDHGJnJl04Pp0UgjLM/d048216da5bb4a18f2c0692e5defc1ef/offline_end2end_flowchart.png\" alt=\"offline end2end flowchart\">\nFigure 6: Offline End-to-End algorithm flowchart. Flowchart diagram for online anomaly detection on the three-storeyed building data set. We take a subset of the data from each sensor, apply variational mode decomposition to obtain the quasi-orthogonal components, Welch transform then take the logarithm and normalise. The transformed data is then concatenated together. We record the updated CACs every 100 new data points, barycenter across the variational modes then finally barycenter over all sensors.</p>\n<p>As it turns out, it is not difficult to make the above algorithm work in an `online' environment, where we process the data as it arrives to get a real-time view of how the CAC responds in real-time. What makes this work is the linear structure of the matrix profile: when a new point is ingested, we only need to recompute the pairwise distances to the new point, which gives a massive reduction in time complexity. For the algorithm in real-time, we compute all of the above transformations (Welch, VMD) in batches as data arrives. We then update the matrix profile one point at a time; every 100 points, we compute the updated CAC and save it in an array. At the end, we produce a gif to visualise how the CAC reacts in real-time to perceived anomalous transitions. For the online methodology flowchart, see Figure 7.</p>\n<p><img src=\"//images.ctfassets.net/j1i7j7n6v3mr/6zWRaEEvDQTCmcjNsIFwBN/5404498936328d6734106b3fb2aadcf3/floss_flowchart.png\" alt=\"floss flowchart\">\nFigure 7: Flowchart diagram for online anomaly detection on the three-storeyed building data set. Beginning with a pre-determined starting subset, we perform the offline algorithm (VMD, log-normalise, etc.) to get the initial CACs at three distinct phases of the data process. We then proceed to update the matrix profiles point-by-point, and every 100 points, record CACs to be animated.</p>\n<p>In the next section, we present a number of notebooks where you can see the results of each data processing step and the final predictors themselves in an online and offline environment.</p>"}},"createdAt":"09 March 2022"}},"pageContext":{"id":"884afc0b-0eff-551b-af4c-ca6e76ac9dfe","title":"A Few Theoretical Ideas","__params":{"title":"a-few-theoretical-ideas"}}},
    "staticQueryHashes": []}